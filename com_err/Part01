#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST Makefile PATCHLEVEL README com_err.3 com_err.c
#   com_err.h compile_et.1 compile_et.c compiler.h error_msg.c
#   error_table.h error_table.y et_lex.lex.l et_name.c init_et.c
#   internal.h sipb-copying.h strcasecmp.c test.c test1.et test2.et
# Wrapped by jik@pit-manager on Mon Mar 11 20:48:45 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(858 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X PATCHLEVEL                 1	
X README                     1	
X c_e.texinfo.Zu             2	
X com_err.3                  1	
X com_err.c                  1	
X com_err.h                  1	
X compile_et.1               1	
X compile_et.c               1	
X compiler.h                 1	
X error_msg.c                1	
X error_table.h              1	
X error_table.y              1	
X et_lex.lex.l               1	
X et_name.c                  1	
X init_et.c                  1	
X internal.h                 1	
X sipb-copying.h             1	
X strcasecmp.c               1	
X test.c                     1	
X test1.et                   1	
X test2.et                   1	
X texinfo.tex.Zu             3	
END_OF_FILE
if test 858 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(4034 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Makefile for error-table routines
X#
X# Copyright 1987, 1989, 1991 MIT Student Information Processing Board
X# For copyright info, see sipb-copying.h.
X#
X#	$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $
X#	$Locker:  $
X#
X
XRANLIB= 	ranlib
X
XDEFINES= 
XCFLAGS=		-O $(DEFINES)
XLINTFLAGS= 	-uhvpb
XLINTFILES= 	error_msg.c et_name.c init_et.c com_err.c
XLIBOBJS= 	error_msg.o et_name.o init_et.o com_err.o
X
XBINDIR=		/usr/bin
XINCDIR=		/usr/include
XLIBDIR=		/usr/lib
XDOCDIR=		/usr/doc
XDESTDIR=
X
XCFILES=		com_err.c compile_et.c error_msg.c et_name.c\
X		init_et.c strcasecmp.c test.c
XHFILES=		com_err.h compiler.h error_table.h internal.h\
X		sipb-copying.h 
XMANS=		com_err.3 compile_et.1
XYACCS=		error_table.y
XLEXS=		et_lex.lex.l
XETS=		test1.et test2.et
XFILES=		Makefile PATCHLEVEL README\
X		c_e.texinfo.Zu texinfo.tex.Zu\
X		$(CFILES) $(HFILES) $(MANS) $(YACCS) $(LEXS) $(ETS)
X
X
X#
X# what to build...
X#
Xall:	compile_et libcom_err.a
X
Xlint:	llib-lcom_err.ln
X
Xarchive:	et.tar
X
Xdoc:	com_err.dvi
X
X#
X# rules
X#
X.SUFFIXES: .h .c .et .ps .x9700 .mss .dvi .texinfo
X
X.et.c:
X	./compile_et $*.et
X
X.et.h:
X	./compile_et $*.et
X
X.texinfo.dvi:
X	tex $<
X
X.dvi.ps:
X	rm -f $@.new
X	dvi2ps -r $< > $@.new
X	mv $@.new $@
X
X
X#
X# real entries...
X#
Xcompile_et:	compile_et.o error_table.o strcasecmp.o
X	${CC} ${CFLAGS} -o compile_et compile_et.o error_table.o\
X		strcasecmp.o -ll
X
Xtags:	TAGS
X
Xcom_err.ps : com_err.dvi
Xcom_err.dvi: comerr.texinfo
X
Xerror_table.o: et_lex.lex.c
X
Xinstall: all
X	install -c -s compile_et ${DESTDIR}${BINDIR}/compile_et
X	install -c -m 444 com_err.h ${DESTDIR}${INCDIR}/com_err.h
X	install -c -m 444 sipb-copying.h \
X				${DESTDIR}${INCDIR}/sipb-copying.h
X	install -c libcom_err.a ${DESTDIR}${LIBDIR}/libcom_err.a
X	${RANLIB} ${DESTDIR}${LIBDIR}/libcom_err.a
X	install -c comerr.texinfo ${DESTDIR}${DOCDIR}/comerr.texinfo
X	install -c com_err.3 ${DESTDIR}/usr/man/man3/com_err.3
X	install -c compile_et.1 ${DESTDIR}/usr/man/man1/compile_et.1
X
XTAGS:	et_name.c error_msg.c compile_et.c error_table.c \
X		lex.yy.c perror.c init_et.c
X	etags et_name.c error_msg.c compile_et.c \
X		error_table.c perror.c init_et.c
X
Xlibcom_err.a:	$(LIBOBJS)
X	ar cruv libcom_err.a $(LIBOBJS)
X	${RANLIB} libcom_err.a
X
Xlibcom_err.o:	$(LIBOBJS)
X	ld -r -s -o libcom_err.o $(LIBOBJS)
X	chmod -x libcom_err.o
X
Xllib-lcom_err.ln: $(LINTFILES)
X	lint -Ccom_err $(LINTFLAGS) $(LINTFILES)
X
Xclean:
X	rm -f *~ \#* *.bak \
X		*.otl *.aux *.toc *.PS *.dvi *.x9700 *.ps \
X		*.cp *.fn *.ky *.log *.pg *.tp *.vr \
X		*.o libcom_err.a \
X		com_err.o compile_et \
X		et.ar TAGS y.tab.c lex.yy.c error_table.c \
X		et_lex.lex.c \
X		test1.h test1.c test2.h test2.c test \
X		eddep makedep
X
Xpatch: $(FILES)
X	makepatch $(FILES)
X	mv patch com_err.patch`cat PATCHLEVEL`
X	shar com_err.patch`cat PATCHLEVEL` > com_err.patch`cat PATCHLEVEL`.shar
X
Xshar: $(FILES)
X	makekit -oMANIFEST $(FILES)
X
Xtar: $(FILES)
X	tar cvf - $(FILES) | compress > com_err.tar.Z
X
Xcomerr.texinfo: c_e.texinfo.Z
X	uncompress < c_e.texinfo.Z > comerr.texinfo
X
Xc_e.texinfo.Z: c_e.texinfo.Zu
X	uudecode c_e.texinfo.Zu
X
Xtexinfo.tex: texinfo.tex.Z
X	uncompress texinfo.tex.Z
X
Xtexinfo.tex.Z: texinfo.tex.Zu
X	uudecode texinfo.tex.Zu
X
X# for testing
Xtest:	test.o test1.o test2.o libcom_err.a
X	cc ${CFLAGS} -o test test.o test1.o test2.o libcom_err.a
Xtest.o:	test1.h test2.h
Xtest1.o : test1.c
Xtest1.c : test1.et
Xtest2.o : test2.c
Xtest2.c : test2.et
X# 'make depend' code
Xdepend: ${CFILES} et_lex.lex.c
X	rm -f eddep makedep
X	/bin/cc -M ${CFLAGS} ${CFILES} | \
X	sed 's; ./; ;' | \
X	sed -e ':loop' \
X	    -e 's/\.\.\/[^ /]*\/\.\./../' \
X	    -e 't loop' > makedep
X# add a blank line so that if there are no dependencies, ed
X# won't report an error (it does on some 
X	echo "$$" > eddep
X	echo "a" >> eddep
X	echo "" >> eddep
X	echo "." >> eddep
X	echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >> eddep
X	echo '$$r makedep' >>eddep
X	echo 'w' >>eddep
X	cp Makefile Makefile.bak
X	ed - Makefile < eddep
X	rm eddep makedep
X#
X# the last line in the makefile should be...
X# DO NOT DELETE THIS LINE -- make depend depends on it.
END_OF_FILE
if test 4034 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'PATCHLEVEL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PATCHLEVEL'\"
else
echo shar: Extracting \"'PATCHLEVEL'\" \(2 characters\)
sed "s/^X//" >'PATCHLEVEL' <<'END_OF_FILE'
X4
END_OF_FILE
if test 2 -ne `wc -c <'PATCHLEVEL'`; then
    echo shar: \"'PATCHLEVEL'\" unpacked with wrong size!
fi
# end of 'PATCHLEVEL'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2541 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X		       ABOUT THE COM_ERR LIBARY
X
X  The com_err library was written by members of the Student
XInformation Processing Board (SIPB) at MIT, to provide a useful
Xstandardized method for dealing with program errors when writing
Xsoftware.
X
X  The version of com_err contained here is currently in flux; the
Xoriginal authors are working on enhancements, although no definite
Xrelease date for them has been set.  You should be aware that when the
Xnew version comes out, the programming interface to the library may
Xchange slightly or not-so-slightly, depending on what the authors feel
Xis needed.
X
X  The file com_err.texinfo (and texinfo.tex, for processing it)
Xcontains the detailed documenation for the library.  They may be
Xcompressed and uuencoded when you receive them, since they contain
Xsome control characters in their original form.
X
X
X			     BUILDING IT
X
X  It should be relatively easy to compile the com_err package on most
Xarchitectures.  To do so, make the following changes to the Makefile:
X
X1. Change RANLIB from "ranlib" to some innocuous command like "echo"
X   if you don't have ranlib on your system.
X
X2. If your system is System V based, add "-DSYSV" to DEFINES.
X
X3. If you plan on installing the library, include files,
X   documentation and compile_et program, change BINDIR, INCDIR,
X   LIBDIR, and DOCDIR.
X
XAfter that, you should be all set.
X
X
X		     I'M LOOKING FOR BETA-TESTERS
X
XI try to make this package run on as many different platforms as
Xpossible.  However, I do not have access to a large variety of
Xplatforms, so I can't effectively test all of the changes I make.  I'm
Xtherefore looking for people who are willing to beta-test changes
Xbefore I release them to the general public.  If you are interested in
Xdoing this, please let me know.
X
X
X			     ARCHIVE SITE
X
XThe most recent version of the com_err package and patches to get from
Xprevious versions to the most recent version are archived on
Xpit-manager.mit.edu (18.72.1.58).  You can retrieve them via anonymous
Xftp in the directory /pub/com_err, or via mail-server (send a message
Xwith the subject "help" to "mail-server@pit-manager.mit.edu").
X
X
X			      QUESTIONS?
X
X  I didn't write com_err, but I'm willing to answer questions and/or
Xdirect them to someone who can.  See my signature to find out how to
Xcontact me.
X
X  See the file sipb-copying.h for copyright and distribution
Xinformation.
X
XJonathan Kamens			              USnail:
XMIT Project Athena				11 Ashford Terrace
Xjik@Athena.MIT.EDU				Allston, MA  02134
XOffice: 617-253-8085			      Home: 617-782-0710
END_OF_FILE
if test 2541 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'com_err.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.3'\"
else
echo shar: Extracting \"'com_err.3'\" \(2535 characters\)
sed "s/^X//" >'com_err.3' <<'END_OF_FILE'
X.\" Copyright (c) 1988 Massachusetts Institute of Technology,
X.\" Student Information Processing Board.  All rights reserved.
X.\"
X.\" $Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $
X.\"
X.TH COM_ERR 3 "22 Nov 1988" SIPB
X.SH NAME
Xcom_err \- common error display routine
X.SH SYNOPSIS
X.nf
X #include <com_err.h>
X.PP
Xvoid com_err (whoami, code, format, ...);
X	const char *whoami;
X	long code;
X	const char *format;
X.PP
Xproc = set_com_err_hook (proc);
X.fi
Xvoid (*
X.I proc
X) (const char *, long, const char *, va_list);
X.nf
X.PP
Xproc = reset_com_err_hook ();
X.PP
Xvoid initialize_XXXX_error_table ();
X.fi
X.SH DESCRIPTION
X.I Com_err
Xdisplays an error message on the standard error stream
X.I stderr
X(see
X.IR stdio (3S))
Xcomposed of the
X.I whoami
Xstring, which should specify the program name or some subportion of
Xa program, followed by an error message generated from the
X.I code
Xvalue (derived from
X.IR compile_et (1)),
Xand a string produced using the
X.I format
Xstring and any following arguments, in the same style as
X.IR fprintf (3).
X
XThe behavior of
X.I com_err
Xcan be modified using
X.I set_com_err_hook;
Xthis defines a procedure which is called with the arguments passed to
X.I com_err,
Xinstead of the default internal procedure which sends the formatted
Xtext to error output.  Thus the error messages from a program can all
Xeasily be diverted to another form of diagnostic logging, such as
X.IR syslog (3).
X.I Reset_com_err_hook
Xmay be used to restore the behavior of
X.I com_err
Xto its default form.  Both procedures return the previous ``hook''
Xvalue.  These ``hook'' procedures must have the declaration given for
X.I proc
Xabove in the synopsis.
X
XThe
X.I initialize_XXXX_error_table
Xroutine is generated mechanically by
X.IR compile_et (1)
Xfrom a source file containing names and associated strings.  Each
Xtable has a name of up to four characters, which is used in place of
Xthe
X.B XXXX
Xin the name of the routine.  These routines should be called before
Xany of the corresponding error codes are used, so that the
X.I com_err
Xlibrary will recognize error codes from these tables when they are
Xused.
X
XThe
X.B com_err.h
Xheader file should be included in any source file that uses routines
Xfrom the
X.I com_err
Xlibrary; executable files must be linked using
X.I ``-lcom_err''
Xin order to cause the
X.I com_err
Xlibrary to be included.
X
X.\" .IR for manual entries
X.\" .PP for paragraph breaks
X
X.SH "SEE ALSO"
Xcompile_et (1), syslog (3).
X
XKen Raeburn, "A Common Error Description Library for UNIX".
END_OF_FILE
if test 2535 -ne `wc -c <'com_err.3'`; then
    echo shar: \"'com_err.3'\" unpacked with wrong size!
fi
# end of 'com_err.3'
fi
if test -f 'com_err.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.c'\"
else
echo shar: Extracting \"'com_err.c'\" \(2892 characters\)
sed "s/^X//" >'com_err.c' <<'END_OF_FILE'
X/*
X * Copyright 1987, 1988 by MIT Student Information Processing Board.
X *
X * For copyright info, see sipb-copying.h.
X */
X
X#include <stdio.h>
X#include "sipb-copying.h"
X
X/*
X * Our environment only provides for ANSI's <stdarg.h> when using GNU
X * C.  Grump grump...
X */
X#if ! __GNUC__
X#define VARARGS 1
X#endif
X
X/* We don't have the v*printf routines... */
X#define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X
X#if __STDC__ && !VARARGS
X#	include <stdarg.h>
X#else /* varargs: not STDC or no <stdarg> */
X	/* Non-ANSI, always take <varargs.h> path. */
X#	undef VARARGS
X#	define VARARGS 1
X#	include <varargs.h>
X#	undef vfprintf
X#	define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X#endif /* varargs */
X
X#include "error_table.h"
X#include "internal.h"
X
X/*
X * Protect us from header version (externally visible) of com_err, so
X * we can survive in a <varargs.h> environment.  I think.
X */
X#define com_err com_err_external
X#include "com_err.h"
X#undef com_err
X
X/* BSD. sigh. */
X#undef vfprintf
X#define vfprintf(stream,fmt,args) _doprnt(fmt,args,stream)
X
X#if ! lint
Xstatic const char rcsid[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif	/* ! lint */
X
Xstatic void
X#ifdef __STDC__
Xdefault_com_err_proc (const char *whoami, long code, const char *fmt, va_list args)
X#else
Xdefault_com_err_proc (whoami, code, fmt, args)
X    const char *whoami;
X    long code;
X    const char *fmt;
X    va_list args;
X#endif
X{
X    if (whoami) {
X	fputs(whoami, stderr);
X	fputs(": ", stderr);
X    }
X    if (code) {
X	fputs(error_message(code), stderr);
X	fputs(" ", stderr);
X    }
X    if (fmt) {
X        vfprintf (stderr, fmt, args);
X    }
X    putc('\n', stderr);
X    /* should do this only on a tty in raw mode */
X    putc('\r', stderr);
X    fflush(stderr);
X}
X
Xerrf com_err_hook = default_com_err_proc;
X
Xvoid com_err_va (whoami, code, fmt, args)
X    const char *whoami;
X    long code;
X    const char *fmt;
X    va_list args;
X{
X    (*com_err_hook) (whoami, code, fmt, args);
X}
X
X#if ! VARARGS
Xvoid com_err (const char *whoami,
X	      long code,
X	      const char *fmt, ...)
X{
X#else
Xvoid com_err (va_alist)
X    va_dcl
X{
X    const char *whoami, *fmt;
X    long code;
X#endif
X    va_list pvar;
X
X    if (!com_err_hook)
X	com_err_hook = default_com_err_proc;
X#if VARARGS
X    va_start (pvar);
X    whoami = va_arg (pvar, const char *);
X    code = va_arg (pvar, long);
X    fmt = va_arg (pvar, const char *);
X#else
X    va_start(pvar, fmt);
X#endif
X    com_err_va (whoami, code, fmt, pvar);
X    va_end(pvar);
X}
X
X#ifdef __STDC__
Xerrf set_com_err_hook (errf new_proc)
X#else
Xerrf set_com_err_hook (new_proc)
X    errf new_proc;
X#endif
X{
X    errf x = com_err_hook;
X    com_err_hook = new_proc ? new_proc : (errf) default_com_err_proc;
X    return x;
X}
X
Xerrf reset_com_err_hook () {
X    errf x = com_err_hook;
X    com_err_hook = default_com_err_proc;
X    return x;
X}
END_OF_FILE
if test 2892 -ne `wc -c <'com_err.c'`; then
    echo shar: \"'com_err.c'\" unpacked with wrong size!
fi
# end of 'com_err.c'
fi
if test -f 'com_err.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'com_err.h'\"
else
echo shar: Extracting \"'com_err.h'\" \(1010 characters\)
sed "s/^X//" >'com_err.h' <<'END_OF_FILE'
X/*
X * Header file for common error description library.
X *
X * Copyright 1988, Student Information Processing Board of the
X * Massachusetts Institute of Technology.
X *
X * For copyright and distribution info, see the documentation supplied
X * with this package.
X */
X
X#ifndef __COM_ERR_H
X
X#ifdef __STDC__
X#ifndef __HIGHC__		/* gives us STDC but not stdarg */
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X/* ANSI C -- use prototypes etc */
Xtypedef void (*errf) (const char *, long, const char *, va_list);
Xvoid com_err (const char *, long, const char *, ...);
Xchar const *error_message (long);
Xvoid (*com_err_hook) (const char *, long, const char *, va_list);
Xerrf set_com_err_hook (errf);
Xvoid (*reset_com_err_hook ()) (const char *, long, const char *, va_list);
X#else
X/* no prototypes */
Xtypedef void (*errf) ();
Xvoid com_err ();
Xchar *error_message ();
Xvoid (*com_err_hook) ();
Xerrf set_com_err_hook();
Xvoid (*reset_com_err_hook ()) ();
X#endif
X
X#define __COM_ERR_H
X#endif /* ! defined(__COM_ERR_H) */
END_OF_FILE
if test 1010 -ne `wc -c <'com_err.h'`; then
    echo shar: \"'com_err.h'\" unpacked with wrong size!
fi
# end of 'com_err.h'
fi
if test -f 'compile_et.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile_et.1'\"
else
echo shar: Extracting \"'compile_et.1'\" \(2239 characters\)
sed "s/^X//" >'compile_et.1' <<'END_OF_FILE'
X.\" Copyright (c) 1988 Massachusetts Institute of Technology,
X.\" Student Information Processing Board.  All rights reserved.
X.\"
X.\" $Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $
X.\"
X.TH COMPILE_ET 1 "22 Nov 1988" SIPB
X.SH NAME
Xcompile_et \- error table compiler
X.SH SYNOPSIS
X.B compile_et
Xfile
X.SH DESCRIPTION
X.B Compile_et
Xconverts a table listing error-code names and associated messages into
Xa C source file suitable for use with the
X.IR com_err (3)
Xlibrary.
X
XThe source file name must end with a suffix of ``.et''; the file
Xconsists of a declaration supplying the name (up to four characters
Xlong) of the error-code table:
X
X.B error_table
X.I name
X
Xfollowed by up to 256 entries of the form:
X
X.B error_code
X.I name,
X"
X.I string
X"
X
Xand a final
X
X.B end
X
Xto indicate the end of the table.
X
XThe name of the table is used to construct the name of a subroutine
X.I initialize_XXXX_error_table
Xwhich must be called in order for the
X.I com_err
Xlibrary to recognize the error table.
X
XThe various error codes defined are assigned sequentially increasing
Xnumbers (starting with a large number computed as a hash function of
Xthe name of the table); thus for compatibility it is suggested that
Xnew codes be added only to the end of an existing table, and that no
Xcodes be removed from tables.
X
XThe names defined in the table are placed into a C header file with
Xpreprocessor directives defining them as integer constants of up to
X32 bits in magnitude.
X
XA C source file is also generated which should be compiled and linked
Xwith the object files which reference these error codes; it contains
Xthe text of the messages and the initialization subroutine.  Both C
Xfiles have names derived from that of the original source file, with
Xthe ``.et'' suffix replaced by ``.c'' and ``.h''.
X
XA ``#'' in the source file is treated as a comment character, and all
Xremaining text to the end of the source line will be ignored.
X
X.SH BUGS
X
XSince
X.B compile_et
Xuses a very simple parser based on
X.IR yacc (1),
Xits error recovery leaves much to be desired.
X
X.\" .IR for manual entries
X.\" .PP for paragraph breaks
X
X.SH "SEE ALSO"
Xcom_err (3).
X
XKen Raeburn, "A Common Error Description Library for UNIX".
END_OF_FILE
if test 2239 -ne `wc -c <'compile_et.1'`; then
    echo shar: \"'compile_et.1'\" unpacked with wrong size!
fi
# end of 'compile_et.1'
fi
if test -f 'compile_et.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile_et.c'\"
else
echo shar: Extracting \"'compile_et.c'\" \(6875 characters\)
sed "s/^X//" >'compile_et.c' <<'END_OF_FILE'
X/*
X *
X * Copyright 1986, 1987, 1988
X * by MIT Student Information Processing Board.
X *
X * For copyright info, see "sipb-copying.h".
X *
X */
X
X#include <stdio.h>
X#ifdef _AUX_SOURCE
X/* AUX uses caddr_t in <sys/file.h>, and it's defined in <sys/types.h> */
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <string.h>
X#include <sys/param.h>
X#include "sipb-copying.h"
X#include "compiler.h"
X
X#ifndef __STDC__
X#define const
X#endif
X
X#ifndef lint
Xstatic const char copyright[] =
X    "Copyright 1987,1988 by MIT Student Information Processing Board";
X
Xstatic const char rcsid_compile_et_c[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif
X
Xextern char *gensym();
Xextern char *current_token;
Xextern int table_number, current;
Xchar buffer[BUFSIZ];
Xchar *table_name = (char *)NULL;
XFILE *hfile, *cfile;
X
X/* C library */
Xextern char *malloc();
Xextern int errno;
X
X/* lex stuff */
Xextern FILE *yyin;
Xextern int yylineno;
X
Xchar * xmalloc (size) unsigned int size; {
X    char * p = malloc (size);
X    if (!p) {
X	perror (whoami);
X	exit (1);
X    }
X    return p;
X}
X
Xstatic int check_arg (str_list, arg) char const *const *str_list, *arg; {
X    while (*str_list)
X	if (!strcmp(arg, *str_list++))
X	    return 1;
X    return 0;
X}
X
Xstatic const char *const debug_args[] = {
X    "d",
X    "debug",
X    0,
X};
X
Xstatic const char *const lang_args[] = {
X    "lang",
X    "language",
X    0,
X};
X
Xstatic const char *const language_names[] = {
X    "C",
X    "K&R C",
X    "C++",
X    0,
X};
X
Xstatic const char * const c_src_prolog[] = {
X    "static const char * const text[] = {\n",
X    0,
X};
X
Xstatic const char * const krc_src_prolog[] = {
X    "#ifdef __STDC__\n",
X    "#define NOARGS void\n",
X    "#else\n",
X    "#define NOARGS\n",
X    "#define const\n",
X    "#endif\n\n",
X    "static const char * const text[] = {\n",
X    0,
X};
X
Xstatic const char *const struct_def[] = {
X    "struct error_table {\n",
X    "    char const * const * msgs;\n",
X    "    long base;\n",
X    "    int n_msgs;\n",
X    "};\n",
X    "struct et_list {\n",
X    "    struct et_list *next;\n",
X    "    const struct error_table * table;\n",
X    "};\n",
X    "extern struct et_list *_et_list;\n",
X    "\n", 0,
X};
X
Xstatic const char warning[] =
X    "/*\n * %s:\n * This file is automatically generated; please do not edit it.\n */\n";
X
X/* pathnames */
Xchar c_file[MAXPATHLEN];	/* output file */
Xchar h_file[MAXPATHLEN];	/* output */
X
Xstatic void usage () {
X    fprintf (stderr, "%s: usage: %s ERROR_TABLE\n",
X	     whoami, whoami);
X    exit (1);
X}
X
Xstatic void dup_err (type, one, two) char const *type, *one, *two; {
X    fprintf (stderr, "%s: multiple %s specified: `%s' and `%s'\n",
X	     whoami, type, one, two);
X    usage ();
X}
X
Xint main (argc, argv) int argc; char **argv; {
X    char *p, *ename;
X    int len;
X    char const * const *cpp;
X    int got_language = 0;
X
X    /* argument parsing */
X    debug = 0;
X    filename = 0;
X    whoami = argv[0];
X    p = strrchr (whoami, '/');
X    if (p)
X	whoami = p+1;
X    while (argv++, --argc) {
X	char *arg = *argv;
X	if (arg[0] != '-') {
X	    if (filename)
X		dup_err ("filenames", filename, arg);
X	    filename = arg;
X	}
X	else {
X	    arg++;
X	    if (check_arg (debug_args, arg))
X		debug++;
X	    else if (check_arg (lang_args, arg)) {
X		got_language++;
X		arg = *++argv, argc--;
X		if (!arg)
X		    usage ();
X		if (language)
X		    dup_err ("languanges", language_names[(int)language], arg);
X#define check_lang(x,v) else if (!strcasecmp(arg,x)) language = v
X		check_lang ("c", lang_C);
X		check_lang ("ansi_c", lang_C);
X		check_lang ("ansi-c", lang_C);
X		check_lang ("krc", lang_KRC);
X		check_lang ("kr_c", lang_KRC);
X		check_lang ("kr-c", lang_KRC);
X		check_lang ("k&r-c", lang_KRC);
X		check_lang ("k&r_c", lang_KRC);
X		check_lang ("c++", lang_CPP);
X		check_lang ("cplusplus", lang_CPP);
X		check_lang ("c-plus-plus", lang_CPP);
X#undef check_lang
X		else {
X		    fprintf (stderr, "%s: unknown language name `%s'\n",
X			     whoami, arg);
X		    fprintf (stderr, "\tpick one of: C K&R-C\n");
X		    exit (1);
X		}
X	    }
X	    else {
X		fprintf (stderr, "%s: unknown control argument -`%s'\n",
X			 whoami, arg);
X		usage ();
X	    }
X	}
X    }
X    if (!filename)
X	usage ();
X    if (!got_language)
X	language = lang_KRC;
X    else if (language == lang_CPP) {
X	fprintf (stderr, "%s: Sorry, C++ support is not yet finished.\n",
X		 whoami);
X	exit (1);
X    }
X
X    p = xmalloc (strlen (filename) + 5);
X    strcpy (p, filename);
X    filename = p;
X    p = strrchr(filename, '/');
X    if (p == (char *)NULL)
X	p = filename;
X    else
X	p++;
X    ename = p;
X    len = strlen (ename);
X    p += len - 3;
X    if (strcmp (p, ".et"))
X	p += 3;
X    *p++ = '.';
X    /* now p points to where "et" suffix should start */
X    /* generate new filenames */
X    strcpy (p, "c");
X    strcpy (c_file, ename);
X    *p = 'h';
X    strcpy (h_file, ename);
X    strcpy (p, "et");
X
X    yyin = fopen(filename, "r");
X    if (!yyin) {
X	perror(filename);
X	exit(1);
X    }
X
X    hfile = fopen(h_file, "w");
X    if (hfile == (FILE *)NULL) {
X	perror(h_file);
X	exit(1);
X    }
X    fprintf (hfile, warning, h_file);
X
X    cfile = fopen(c_file, "w");
X    if (cfile == (FILE *)NULL) {
X	perror(c_file);
X	exit(1);
X    }
X    fprintf (cfile, warning, c_file);
X
X    /* prologue */
X    if (language == lang_C)
X	cpp = c_src_prolog;
X    else if (language == lang_KRC)
X	cpp = krc_src_prolog;
X    else
X	abort ();
X    while (*cpp)
X	fputs (*cpp++, cfile);
X
X    /* parse it */
X    yyparse();
X    fclose(yyin);		/* bye bye input file */
X
X    fputs ("    0\n};\n\n", cfile);
X    for (cpp = struct_def; *cpp; cpp++)
X	fputs (*cpp, cfile);
X    fprintf(cfile,
X	    "static const struct error_table et = { text, %ldL, %d };\n\n",
X	    table_number, current);
X    fputs("static struct et_list link = { 0, 0 };\n\n",
X	  cfile);
X    fprintf(cfile, "void initialize_%s_error_table (%s) {\n",
X	    table_name, (language == lang_C) ? "void" : "NOARGS");
X    fputs("    if (!link.table) {\n", cfile);
X    fputs("        link.next = _et_list;\n", cfile);
X    fputs("        link.table = &et;\n", cfile);
X    fputs("        _et_list = &link;\n", cfile);
X    fputs("    }\n", cfile);
X    fputs("}\n", cfile);
X    fclose(cfile);
X
X    fprintf (hfile, "extern void initialize_%s_error_table ();\n",
X	     table_name);
X    fprintf (hfile, "#define ERROR_TABLE_BASE_%s (%ldL)\n",
X	     table_name, table_number);
X    /* compatibility... */
X    fprintf (hfile, "\n/* for compatibility with older versions... */\n");
X    fprintf (hfile, "#define init_%s_err_tbl initialize_%s_error_table\n",
X	     table_name, table_name);
X    fprintf (hfile, "#define %s_err_base ERROR_TABLE_BASE_%s\n", table_name,
X	     table_name);
X    fclose(hfile);		/* bye bye include file */
X
X    return 0;
X}
X
Xint yyerror(s) char *s; {
X    fputs(s, stderr);
X    fprintf(stderr, "\nLine number %d; last token was '%s'\n",
X	    yylineno, current_token);
X}
END_OF_FILE
if test 6875 -ne `wc -c <'compile_et.c'`; then
    echo shar: \"'compile_et.c'\" unpacked with wrong size!
fi
# end of 'compile_et.c'
fi
if test -f 'compiler.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compiler.h'\"
else
echo shar: Extracting \"'compiler.h'\" \(379 characters\)
sed "s/^X//" >'compiler.h' <<'END_OF_FILE'
X/*
X * definitions common to the source files of the error table compiler
X */
X
X#ifndef __STDC__
X/* loser */
X#undef const
X#define const
X#endif
X
Xenum lang {
X    lang_C,			/* ANSI C (default) */
X    lang_KRC,			/* C: ANSI + K&R */
X    lang_CPP			/* C++ */
X};
X
Xint debug;			/* dump debugging info? */
Xchar *filename;			/* error table source */
Xenum lang language;
Xconst char *whoami;
END_OF_FILE
if test 379 -ne `wc -c <'compiler.h'`; then
    echo shar: \"'compiler.h'\" unpacked with wrong size!
fi
# end of 'compiler.h'
fi
if test -f 'error_msg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_msg.c'\"
else
echo shar: Extracting \"'error_msg.c'\" \(1845 characters\)
sed "s/^X//" >'error_msg.c' <<'END_OF_FILE'
X/*
X * $Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $
X * $Source: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v $
X * $Locker:  $
X *
X * Copyright 1987 by the Student Information Processing Board
X * of the Massachusetts Institute of Technology
X *
X * For copyright info, see "sipb-copying.h".
X */
X
X#include <stdio.h>
X#include "error_table.h"
X#include "sipb-copying.h"
X#include "internal.h"
X
Xstatic const char rcsid[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
Xstatic const char copyright[] =
X    "Copyright 1986, 1987, 1988 by the Student Information Processing Board\nand the department of Information Systems\nof the Massachusetts Institute of Technology";
X
Xstatic char buffer[25];
X
Xstruct et_list * _et_list = (struct et_list *) NULL;
X
Xconst char * error_message (code)
Xlong	code;
X{
X    int offset;
X    struct et_list *et;
X    int table_num;
X    int started = 0;
X    char *cp;
X
X    offset = code & ((1<<ERRCODE_RANGE)-1);
X    table_num = code - offset;
X    if (!table_num) {
X	if (offset < sys_nerr)
X	    return(sys_errlist[offset]);
X	else
X	    goto oops;
X    }
X    for (et = _et_list; et; et = et->next) {
X	if (et->table->base == table_num) {
X	    /* This is the right table */
X	    if (et->table->n_msgs <= offset)
X		goto oops;
X	    return(et->table->msgs[offset]);
X	}
X    }
Xoops:
X    strcpy (buffer, "Unknown code ");
X    if (table_num) {
X	strcat (buffer, error_table_name (table_num));
X	strcat (buffer, " ");
X    }
X    for (cp = buffer; *cp; cp++)
X	;
X    if (offset >= 100) {
X	*cp++ = '0' + offset / 100;
X	offset %= 100;
X	started++;
X    }
X    if (started || offset >= 10) {
X	*cp++ = '0' + offset / 10;
X	offset %= 10;
X    }
X    *cp++ = '0' + offset;
X    *cp = '\0';
X    return(buffer);
X}
END_OF_FILE
if test 1845 -ne `wc -c <'error_msg.c'`; then
    echo shar: \"'error_msg.c'\" unpacked with wrong size!
fi
# end of 'error_msg.c'
fi
if test -f 'error_table.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_table.h'\"
else
echo shar: Extracting \"'error_table.h'\" \(657 characters\)
sed "s/^X//" >'error_table.h' <<'END_OF_FILE'
X/*
X * Copyright 1988 by the Student Information Processing Board of the
X * Massachusetts Institute of Technology.
X *
X * For copyright info, see sipb-copying.h.
X */
X
X#ifndef _ET_H
X/* Are we using ANSI C? */
X#ifndef __STDC__
X#define const
X#endif
Xextern int errno;
Xstruct error_table {
X    char const * const * msgs;
X    long base;
X    int n_msgs;
X};
Xstruct et_list {
X    struct et_list *next;
X    const struct error_table *table;
X};
Xextern struct et_list * _et_list;
X
X#define	ERRCODE_RANGE	8	/* # of bits to shift table number */
X#define	BITS_PER_CHAR	6	/* # bits to shift per character in name */
X
Xextern const char *error_table_name();
X#define _ET_H
X#endif
END_OF_FILE
if test 657 -ne `wc -c <'error_table.h'`; then
    echo shar: \"'error_table.h'\" unpacked with wrong size!
fi
# end of 'error_table.h'
fi
if test -f 'error_table.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error_table.y'\"
else
echo shar: Extracting \"'error_table.y'\" \(4829 characters\)
sed "s/^X//" >'error_table.y' <<'END_OF_FILE'
X%{
X#include <stdio.h>
X#if !defined(__STDC__) || defined(__HIGHC__)
Xchar *malloc(), *realloc();
X#endif     
Xchar *str_concat(), *ds(), *quote();
Xchar *current_token = (char *)NULL;
Xextern char *table_name;
X%}
X%union {
X	char *dynstr;
X}
X
X%token ERROR_TABLE ERROR_CODE_ENTRY END
X%token <dynstr> STRING QUOTED_STRING
X%type <dynstr> ec_name description table_id
X%{
X%}
X%start error_table
X%%
X
Xerror_table	:	ERROR_TABLE table_id error_codes END
X			{ table_name = ds($2);
X			  current_token = table_name;
X			  put_ecs(); }
X		;
X
Xtable_id	:	STRING
X			{ current_token = $1;
X			  set_table_num($1);
X			  $$ = $1; }
X		;
X
Xerror_codes	:	error_codes ec_entry
X		|	ec_entry
X		;
X
Xec_entry	:	ERROR_CODE_ENTRY ec_name ',' description
X			{ add_ec($2, $4);
X			  free($2);
X			  free($4); }
X		|	ERROR_CODE_ENTRY ec_name '=' STRING ',' description
X			{ add_ec_val($2, $4, $6);
X			  free($2);
X			  free($4);
X			  free($6);
X			}
X		;
X
Xec_name		:	STRING
X			{ $$ = ds($1);
X			  current_token = $$; }
X		;
X
Xdescription	:	QUOTED_STRING
X			{ $$ = ds($1);
X			  current_token = $$; }
X		;
X
X%%
X/*
X *
X * Copyright 1986, 1987 by the MIT Student Information Processing Board
X *
X * For copyright info, see sipb-copying.h.
X */
X
X#ifdef SYSV
X#include <string.h>
X#define index strchr
X#define rindex strrchr
X#else
X#include <strings.h>
X#endif
X#include <assert.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "internal.h"
X#include "error_table.h"
X#include "sipb-copying.h"
X
X#ifndef	lint
Xstatic char const rcsid_error_table_y[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif
X
Xextern FILE *hfile, *cfile;
X
Xstatic long gensym_n = 0;
Xchar *
Xgensym(x)
X	char const *x;
X{
X	char *symbol;
X	if (!gensym_n) {
X		struct timeval tv;
X		struct timezone tzp;
X		gettimeofday(&tv, &tzp);
X		gensym_n = (tv.tv_sec%10000)*100 + tv.tv_usec/10000;
X	}
X	symbol = malloc(32 * sizeof(char));
X	gensym_n++;
X	sprintf(symbol, "et%ld", gensym_n);
X	return(symbol);
X}
X
Xchar *
Xds(string)
X	char const *string;
X{
X	char *rv;
X	rv = malloc(strlen(string)+1);
X	strcpy(rv, string);
X	return(rv);
X}
X
Xchar *
Xquote(string)
X	char const *string;
X{
X	char *rv;
X	rv = malloc(strlen(string)+3);
X	strcpy(rv, "\"");
X	strcat(rv, string);
X	strcat(rv, "\"");
X	return(rv);
X}
X
Xlong table_number;
Xint current = 0;
Xchar **error_codes = (char **)NULL;
X
Xadd_ec(name, description)
X	char const *name, *description;
X{
X	fprintf(cfile, "\t\"%s\",\n", description);
X	if (error_codes == (char **)NULL) {
X		error_codes = (char **)malloc(sizeof(char *));
X		*error_codes = (char *)NULL;
X	}
X	error_codes = (char **)realloc((char *)error_codes,
X				       (current + 2)*sizeof(char *));
X	error_codes[current++] = ds(name);
X	error_codes[current] = (char *)NULL;
X}
X
Xadd_ec_val(name, val, description)
X	char const *name, *val, *description;
X{
X	const int ncurrent = atoi(val);
X	if (ncurrent < current) {
X		printf("Error code %s (%d) out of order", name,
X		       current);
X		return;
X	}
X      
X	while (ncurrent > current)
X	     fputs("\t(char *)NULL,\n", cfile), current++;
X	
X	fprintf(cfile, "\t\"%s\",\n", description);
X	if (error_codes == (char **)NULL) {
X		error_codes = (char **)malloc(sizeof(char *));
X		*error_codes = (char *)NULL;
X	}
X	error_codes = (char **)realloc((char *)error_codes,
X				       (current + 2)*sizeof(char *));
X	error_codes[current++] = ds(name);
X	error_codes[current] = (char *)NULL;
X} 
X
Xput_ecs()
X{
X	int i;
X	for (i = 0; i < current; i++) {
X	     if (error_codes[i] != (char *)NULL)
X		  fprintf(hfile, "#define %-40s (%ldL)\n",
X			  error_codes[i], table_number + i);
X	}
X}
X
X/*
X * char_to_num -- maps letters and numbers into a small numbering space
X * 	uppercase ->  1-26
X *	lowercase -> 27-52
X *	digits    -> 53-62
X *	underscore-> 63
X */
X
Xstatic const char char_set[] =
X	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
X
Xint char_to_num(c)
X	char c;
X{
X	const char *where;
X	int diff;
X
X	where = strchr (char_set, c);
X	if (where) {
X		diff = where - char_set + 1;
X		assert (diff < (1 << ERRCODE_RANGE));
X		return diff;
X	}
X	else if (isprint (c))
X		fprintf (stderr,
X			 "Illegal character `%c' in error table name\n",
X			 c);
X	else
X		fprintf (stderr,
X			 "Illegal character %03o in error table name\n",
X			 c);
X	exit (1);
X}
X
Xset_table_num(string)
X	char *string;
X{
X	if (char_to_num (string[0]) > char_to_num ('z')) {
X		fprintf (stderr, "%s%s%s%s",
X			 "First character of error table name must be ",
X			 "a letter; name ``",
X			 string, "'' rejected\n");
X		exit (1);
X	}
X	if (strlen(string) > 4) {
X		fprintf(stderr, "Table name %s too long, truncated ",
X			string);
X		string[4] = '\0';
X		fprintf(stderr, "to %s\n", string);
X	}
X	while (*string != '\0') {
X		table_number = (table_number << BITS_PER_CHAR)
X			+ char_to_num(*string);
X		string++;
X	}
X	table_number = table_number << ERRCODE_RANGE;
X}
X
X#include "et_lex.lex.c"
END_OF_FILE
if test 4829 -ne `wc -c <'error_table.y'`; then
    echo shar: \"'error_table.y'\" unpacked with wrong size!
fi
# end of 'error_table.y'
fi
if test -f 'et_lex.lex.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'et_lex.lex.l'\"
else
echo shar: Extracting \"'et_lex.lex.l'\" \(704 characters\)
sed "s/^X//" >'et_lex.lex.l' <<'END_OF_FILE'
XPC	[^\"]
XAN	[A-Z_a-z0-9]
X%{
X#ifdef SYSV
X#include <string.h>
X#define index strchr
X#define rindex strrchr
X#else
X#include <strings.h>
X#endif /* SYSV */
X%}
X%%
X
Xerror_table	return ERROR_TABLE;
Xet		return ERROR_TABLE;
Xerror_code	return ERROR_CODE_ENTRY;
Xec		return ERROR_CODE_ENTRY;
Xend		return END;
X
X[\t\n ]		;
X
X\"{PC}*\"	{ register char *p; yylval.dynstr = ds(yytext+1);
X		  if (p=rindex(yylval.dynstr, '"')) *p='\0';
X		  return QUOTED_STRING;
X		}
X
X{AN}*	{ yylval.dynstr = ds(yytext); return STRING; }
X
X#.*\n		;
X
X.		{ return (*yytext); }
X%%
X#ifndef lint
Xstatic char rcsid_et_lex_lex_l[] = "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif
END_OF_FILE
if test 704 -ne `wc -c <'et_lex.lex.l'`; then
    echo shar: \"'et_lex.lex.l'\" unpacked with wrong size!
fi
# end of 'et_lex.lex.l'
fi
if test -f 'et_name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'et_name.c'\"
else
echo shar: Extracting \"'et_name.c'\" \(1123 characters\)
sed "s/^X//" >'et_name.c' <<'END_OF_FILE'
X/*
X * Copyright 1987 by MIT Student Information Processing Board
X *
X * For copyright info, see sipb-copying.h.
X */
X
X#include "error_table.h"
X#include "sipb-copying.h"
X#include "internal.h"
X
X#ifndef	lint
Xstatic const char copyright[] =
X    "Copyright 1987,1988 by Student Information Processing Board, Massachusetts Institute of Technology";
Xstatic const char rcsid_et_name_c[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif
X
Xstatic const char char_set[] =
X	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
X
Xstatic char buf[6];
X
Xconst char * error_table_name(num)
X    int num;
X{
X    int ch;
X    int i;
X    char *p;
X
X    /* num = aa aaa abb bbb bcc ccc cdd ddd d?? ??? ??? */
X    p = buf;
X    num >>= ERRCODE_RANGE;
X    /* num = ?? ??? ??? aaa aaa bbb bbb ccc ccc ddd ddd */
X    num &= 077777777;
X    /* num = 00 000 000 aaa aaa bbb bbb ccc ccc ddd ddd */
X    for (i = 4; i >= 0; i--) {
X	ch = (num >> BITS_PER_CHAR * i) & ((1 << BITS_PER_CHAR) - 1);
X	if (ch != 0)
X	    *p++ = char_set[ch-1];
X    }
X    *p = '\0';
X    return(buf);
X}
END_OF_FILE
if test 1123 -ne `wc -c <'et_name.c'`; then
    echo shar: \"'et_name.c'\" unpacked with wrong size!
fi
# end of 'et_name.c'
fi
if test -f 'init_et.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init_et.c'\"
else
echo shar: Extracting \"'init_et.c'\" \(1278 characters\)
sed "s/^X//" >'init_et.c' <<'END_OF_FILE'
X/*
X * $Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $
X * $Source: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v $
X * $Locker:  $
X *
X * Copyright 1986, 1987, 1988 by MIT Information Systems and
X *	the MIT Student Information Processing Board.
X *
X * For copyright info, see sipb-copying.h.
X */
X
X#include <stdio.h>
X#include "error_table.h"
X#include "sipb-copying.h"
X
X#ifndef __STDC__
X#define const
X#endif
X
X#ifndef	lint
Xstatic const char rcsid_init_et_c[] =
X    "$Header: /afs/dev.mit.edu/source/repository/athena/bin/delete/com_err/Part01,v 1.1 1993-10-12 06:02:16 probe Exp $";
X#endif
X
Xextern char *malloc(), *realloc();
X
Xstruct foobar {
X    struct et_list etl;
X    struct error_table et;
X};
X
Xextern struct et_list * _et_list;
X
Xint init_error_table(msgs, base, count)
X    const char * const * msgs;
X    int base;
X    int count;
X{
X    struct foobar * new_et;
X
X    if (!base || !count || !msgs)
X	return 0;
X
X    new_et = (struct foobar *) malloc(sizeof(struct foobar));
X    if (!new_et)
X	return errno;	/* oops */
X    new_et->etl.table = &new_et->et;
X    new_et->et.msgs = msgs;
X    new_et->et.base = base;
X    new_et->et.n_msgs= count;
X
X    new_et->etl.next = _et_list;
X    _et_list = &new_et->etl;
X    return 0;
X}
END_OF_FILE
if test 1278 -ne `wc -c <'init_et.c'`; then
    echo shar: \"'init_et.c'\" unpacked with wrong size!
fi
# end of 'init_et.c'
fi
if test -f 'internal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'internal.h'\"
else
echo shar: Extracting \"'internal.h'\" \(284 characters\)
sed "s/^X//" >'internal.h' <<'END_OF_FILE'
X/*
X * internal include file for com_err package
X */
X#include "sipb-copying.h"
X#ifndef __STDC__
X#undef const
X#define const
X#endif
X
Xextern int errno;
Xextern char const * const sys_errlist[];
Xextern const int sys_nerr;
X
X#if !defined(__STDC__) || defined(__HIGHC__)
Xint perror ();
X#endif
END_OF_FILE
if test 284 -ne `wc -c <'internal.h'`; then
    echo shar: \"'internal.h'\" unpacked with wrong size!
fi
# end of 'internal.h'
fi
if test -f 'sipb-copying.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sipb-copying.h'\"
else
echo shar: Extracting \"'sipb-copying.h'\" \(775 characters\)
sed "s/^X//" >'sipb-copying.h' <<'END_OF_FILE'
X/*
X
XCopyright 1987, 1988, 1991 by the Student Information Processing Board
X	of the Massachusetts Institute of Technology
X
XPermission to use, copy, modify, and distribute this software
Xand its documentation for any purpose and without fee is
Xhereby granted, provided that the above copyright notice
Xappear in all copies and that both that copyright notice and
Xthis permission notice appear in supporting documentation,
Xand that the names of M.I.T. and the M.I.T. S.I.P.B. not be
Xused in advertising or publicity pertaining to distribution
Xof the software without specific, written prior permission.
XM.I.T. and the M.I.T. S.I.P.B. make no representations about
Xthe suitability of this software for any purpose.  It is
Xprovided "as is" without express or implied warranty.
X
X*/
X
END_OF_FILE
if test 775 -ne `wc -c <'sipb-copying.h'`; then
    echo shar: \"'sipb-copying.h'\" unpacked with wrong size!
fi
# end of 'sipb-copying.h'
fi
if test -f 'strcasecmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strcasecmp.c'\"
else
echo shar: Extracting \"'strcasecmp.c'\" \(3767 characters\)
sed "s/^X//" >'strcasecmp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)strcasecmp.c	5.6 (Berkeley) 6/27/88";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X
X/*
X * This array is designed for mapping upper and lower case letter
X * together for a case independent comparison.  The mappings are
X * based upon ascii character sequences.
X */
Xstatic u_char charmap[] = {
X	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
X	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
X	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
X	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
X	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
X	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
X	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
X	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
X	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
X	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
X	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
X	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
X	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
X	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
X	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
X	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
X	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
X	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
X	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
X	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
X};
X
Xstrcasecmp(s1, s2)
X	char *s1, *s2;
X{
X	register u_char	*cm = charmap,
X			*us1 = (u_char *)s1,
X			*us2 = (u_char *)s2;
X
X	while (cm[*us1] == cm[*us2++])
X		if (*us1++ == '\0')
X			return(0);
X	return(cm[*us1] - cm[*--us2]);
X}
X
Xstrncasecmp(s1, s2, n)
X	char *s1, *s2;
X	register int n;
X{
X	register u_char	*cm = charmap,
X			*us1 = (u_char *)s1,
X			*us2 = (u_char *)s2;
X
X	while (--n >= 0 && cm[*us1] == cm[*us2++])
X		if (*us1++ == '\0')
X			return(0);
X	return(n < 0 ? 0 : cm[*us1] - cm[*--us2]);
X}
END_OF_FILE
if test 3767 -ne `wc -c <'strcasecmp.c'`; then
    echo shar: \"'strcasecmp.c'\" unpacked with wrong size!
fi
# end of 'strcasecmp.c'
fi
if test -f 'test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.c'\"
else
echo shar: Extracting \"'test.c'\" \(1798 characters\)
sed "s/^X//" >'test.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include "com_err.h"
X#include "test1.h"
X#include "test2.h"
X
Xextern int sys_nerr, errno;
X
Xmain()
X{
X	printf("Before initiating error table:\n\n");
X	printf("Table name '%s'\n", error_table_name(KRB_MK_AP_TGTEXP));
X	printf("UNIX  name '%s'\n", error_table_name(EPERM));
X	printf("Msg TGT-expired is '%s'\n", error_message(KRB_MK_AP_TGTEXP));
X	printf("Msg EPERM is '%s'\n", error_message(EPERM));
X	printf("Msg FOO_ERR is '%s'\n", error_message(FOO_ERR));
X	printf("Msg {sys_nerr-1} is '%s'\n", error_message(sys_nerr-1));
X	printf("Msg {sys_nerr} is '%s'\n", error_message(sys_nerr));
X
X	printf("With 0: tgt-expired -> %s\n", error_message(KRB_MK_AP_TGTEXP));
X
X	initialize_krb_error_table();
X	printf("KRB error table initialized:  base %d (%s), name %s\n",
X	       ERROR_TABLE_BASE_krb, error_message(ERROR_TABLE_BASE_krb),
X	       error_table_name(ERROR_TABLE_BASE_krb));
X	initialize_krb_error_table();
X	printf("With krb: tgt-expired -> %s\n",
X	       error_message(KRB_MK_AP_TGTEXP));
X
X	initialize_quux_error_table();
X	printf("QUUX error table initialized: base %d (%s), name %s\n",
X	       ERROR_TABLE_BASE_quux, error_message(ERROR_TABLE_BASE_quux),
X	       error_table_name(ERROR_TABLE_BASE_quux));
X
X	printf("Msg for TGT-expired is '%s'\n",
X	       error_message(KRB_MK_AP_TGTEXP));
X	printf("Msg {sys_nerr-1} is '%s'\n", error_message(sys_nerr-1));
X	printf("Msg FOO_ERR is '%s'\n", error_message(FOO_ERR));
X	printf("Msg KRB_SKDC_CANT is '%s'\n",
X		    error_message(KRB_SKDC_CANT));
X	printf("Msg 1e6 (8B 64) is '%s'\n", error_message(1000000));
X	printf("\n\nCOM_ERR tests:\n");
X	com_err("whoami", FOO_ERR, (char *)NULL);
X	com_err("whoami", FOO_ERR, " -- message goes %s", "here");
X	com_err("whoami", 0, (char *)0);
X	com_err("whoami", 0, "error number %d\n", 0);
X}
END_OF_FILE
if test 1798 -ne `wc -c <'test.c'`; then
    echo shar: \"'test.c'\" unpacked with wrong size!
fi
# end of 'test.c'
fi
if test -f 'test1.et' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test1.et'\"
else
echo shar: Extracting \"'test1.et'\" \(1129 characters\)
sed "s/^X//" >'test1.et' <<'END_OF_FILE'
X	error_table	krb
X
X	error_code	KRB_MK_AP_TKFIL,
X			"Can't read ticket file"
X
X	ec		KRB_MK_AP_NOTKT,
X			"Can't find ticket or TGT"
X
X	ec		KRB_MK_AP_TGTEXP,
X			"TGT expired"
X
X	ec		KRB_RD_AP_UNDEC,
X			"Can't decode authenticator"
X
X	ec		KRB_RD_AP_EXP,
X			"Ticket expired"
X
X	ec		KRB_RD_AP_REPEAT,
X			"Repeated request"
X
X	ec		KRB_RD_AP_NOT_US,
X			"The ticket isn't for us"
X
X	ec		KRB_RD_AP_INCON,
X			"Request is inconsistent"
X
X	ec		KRB_RD_AP_TIME,
X			"Delta-T too big"
X
X	ec		KRB_RD_AP_BADD,
X			"Incorrect net address"
X
X	ec		KRB_RD_AP_VERSION,
X			"Protocol version mismatch"
X
X	ec		KRB_RD_AP_MSG_TYPE,
X			"Invalid message type"
X
X	ec		KRB_RD_AP_MODIFIED,
X			"Message stream modified"
X
X	ec		KRB_RD_AP_ORDER,
X			"Message out of order"
X
X	ec		KRB_RD_AP_UNAUTHOR,
X			"Unauthorized request"
X
X	ec		KRB_GT_PW_NULL,
X			"Current password is null"
X
X	ec		KRB_GT_PW_BADPW,
X			"Incorrect current password"
X
X	ec		KRB_GT_PW_PROT,
X			"Protocol error"
X
X	ec		KRB_GT_PW_KDCERR,
X			"Error returned by KDC"
X
X	ec		KRB_GT_PW_NULLTKT,
X			"Null ticket returned by KDC"
X
X	ec		KRB_SKDC_RETRY,
X			"Retry count exceeded"
X
X	ec		KRB_SKDC_CANT,
X			"Can't send request"
X
X	end
END_OF_FILE
if test 1129 -ne `wc -c <'test1.et'`; then
    echo shar: \"'test1.et'\" unpacked with wrong size!
fi
# end of 'test1.et'
fi
if test -f 'test2.et' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test2.et'\"
else
echo shar: Extracting \"'test2.et'\" \(85 characters\)
sed "s/^X//" >'test2.et' <<'END_OF_FILE'
X	error_table	quux
X
X	ec	FOO_ERR, "foo"
X
X	ec	BAR_ERR, "bar"
X
X	ec	BAZ_ERR, "meow"
X
X	end
END_OF_FILE
if test 85 -ne `wc -c <'test2.et'`; then
    echo shar: \"'test2.et'\" unpacked with wrong size!
fi
# end of 'test2.et'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
